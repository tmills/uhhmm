"""
Script for batch execution of random PCFG generation and tree sampling

@author: Cory Shain
"""

import sys, argparse, numpy as np
from PCFG_Generator import PCFG_Generator

argparser = argparse.ArgumentParser('''
Generates batches of random PCFGs and trees sampled from them.
''')
argparser.add_argument('-o', '--output_dir', dest='output_dir', default='.', action='store', help='Output directory path.')
argparser.add_argument('-n', '--dry_run', dest='dry_run', action='store_true', help='Just print a list of the files that would be generated by the command line call, without actually generating them.')
argparser.add_argument('-t', '--num_trees', dest='num_trees', default='20000', action='store', help='Number of trees to sample from each generated PCFG. num_trees can be specified as a single integer, a range of integers "start:end" (in which case a step size of 1 will be used), or a range of integers with an integer step specification "start:step:end". If left unspecified, defaults to 20000.')
argparser.add_argument('-a', '--a_size', dest='a_size', default='5', action='store', help='Number of states in A (active category) variable. a_size can be specified as a single integer, a range of integers "start:end" (in which case a step size of 1 will be used), or a range of integers with an integer step specification "start:step:end". If left unspecified, defaults to 5.')
argparser.add_argument('-b', '--b_size', dest='b_size', default='5', action='store', help='Number of states in B (awaited category) variable. b_size can be specified as a single integer, a range of integers "start:end" (in which case a step size of 1 will be used), or a range of integers with an integer step specification "start:step:end". If left unspecified, defaults to 5.')
argparser.add_argument('-p', '--p_size', dest='p_size', default='5', action='store', help='Number of states in P (part-of-speech category) variable. p_size can be specified as a single integer, a range of integers "start:end" (in which case a step size of 1 will be used), or a range of integers with an integer step specification "start:step:end". If left unspecified, defaults to 5.')
argparser.add_argument('-w', '--w_size', dest='w_size', default='2000', action='store', help='Number of states in W (word category) variable. w_size can be specified as a single integer, a range of integers "start:end" (in which case a step size of 1 will be used), or a range of integers with an integer step specification "start:step:end". If left unspecified, defaults to 1.')
argparser.add_argument('-d', '--depth', dest='depth', default=None, action='store', help='Embedding depth bound. Depth can be specified as a single integer, a range of integers "start:end" (in which case a step size of 1 will be used), or a range of integers with an integer step specification "start:step:end". If left unspecified, defaults to 1.')
argparser.add_argument('-B', '--branching', dest='branching', default=None, action='store', help='Branching direction (i.e. left-branching probability). 0 <= branching <= 1, where 0 is totally right-branching and 1 is totally left-branching. Branching can be specified as a single scalar, a range of scalars "start:end" (in which case a step size of 0.1 will be used), or a range with a step specification "start:step:end". If left unspecified, defaults to <None>, and branching probability will be determined empirically (relative number of left and right branching rules).')
argparser.add_argument('-R', '--recursion', dest='recursion', default=None, action='store', help='Recursion probability. 0 <= recursion < 1. Recursion can be specified as a single scalar, a range of scalars "start:end" (in which case a step size of 0.1 will be used), or a range with a step specification "start:step:end". If left unspecified, defaults to <None>, and recursion probability will be determined empirically (relative number of non-recursive rules).')
argparser.add_argument('-T', '--termination', dest='termination', default=None, action='store', help='Branch termination (bottom-out) probability. 0 < recursion <= 1. Termination can be specified as a single scalar, a range of scalars "start:end" (in which case a step size of 0.1 will be used), or a range with a step specification "start:step:end". If left unspecified, defaults to <None>, and termination probability will be determined empirically (relative number of non-terminating rules).')
argparser.add_argument('-O', '--oneword', dest='oneword', default=None, action='store', help='Probability of generating a one-word sentence. 0 < oneword <= 1. One-word probability can be specified as a single scalar, a range of scalars "start:end" (in which case a step size of 0.1 will be used), or a range with a step specification "start:step:end". If left unspecified, defaults to <None>, and one-word probability will be determined empirically (relative number of non-terminating rules).')
args, unknown = argparser.parse_known_args()

def process_range(s):
  s = s.split(':')
  assert len(s) > 0 and len(s) <=3, 'Improperly formatted CLI argument: %s' %s
  if len(s) == 1:
    return [int(s[0])]
  if len(s) == 2:
    return range(int(s[0]), int(s[1]))
  return range(int(s[0]), int(s[2]), int(s[1]))

def process_prob(s):
  if s is None:
    return [s]
  s = s.split(':')
  assert len(s) > 0 and len(s) <=3, 'Improperly formatted CLI argument: %s' %s
  if len(s) == 1:
    return [float(s[0])]
  if len(s) == 2:
    return list(np.arange(float(s[0]), float(s[1]), 0.1))
  return list(np.arange(float(s[0]), float(s[2]), float(s[1])))

args.num_trees = process_range(args.num_trees)
args.a_size = process_range(args.a_size)
args.b_size = process_range(args.b_size)
args.p_size = process_range(args.p_size)
args.w_size = process_range(args.w_size)
if args.depth != None:
  args.depth = process_range(args.depth)
else:
  args.depth = [None]
args.branching = process_prob(args.branching)
args.recursion = process_prob(args.recursion)
args.termination = process_prob(args.termination)
args.oneword = process_prob(args.oneword)


def main():
  if args.dry_run:
    print('Dry run. Would generate the following files:')
    print('')
  for params in [(t,a,b,p,w,d,B,R,T,O) for t in args.num_trees \
                                   for a in args.a_size \
                                   for b in args.b_size \
                                   for p in args.p_size \
                                   for w in args.w_size \
                                   for d in args.depth \
                                   for B in args.branching \
                                   for R in args.recursion \
                                   for T in args.termination \
                                   for O in args.oneword]:
     t, a, b, p, w, d, B, R, T, O = params

     sys.stderr.write('Generating model and sampling trees using the following configuration:\n')
     sys.stderr.write('  t=%s\n'%t)
     sys.stderr.write('  a=%s\n'%a)
     sys.stderr.write('  b=%s\n'%b)
     sys.stderr.write('  p=%s\n'%p)
     sys.stderr.write('  w=%s\n'%w)
     sys.stderr.write('  d=%s\n'%d)
     sys.stderr.write('  B=%s\n'%B)
     sys.stderr.write('  R=%s\n'%R)
     sys.stderr.write('  T=%s\n'%T)
     sys.stderr.write('  O=%s\n'%O)

     if d is None:
       d_str = 'None'
     else:
       d_str = '%d'%d
     if B is None:
       B_str = 'None'
     else:
       B_str = ('%.3f'%B)[2:]
     if R is None:
       R_str = 'None'
     else:
       R_str = ('%.3f'%R)[2:]
     if T is None:
       T_str = 'None'
     else:
       T_str = ('%.3f'%T)[2:]
     if O is None:
       O_str = 'None'
     else:
       O_str = ('%.3f'%O)[2:]
     basename = args.output_dir + '/PCFG_t%s_a%s_b%s_p%s_w%s_d%s_B%s_R%s_T%s_O%s' %(t, a, b, p, w, d_str, B_str, R_str, T_str, O_str)
     
     if args.dry_run:
       print('  ' + basename + '.linetrees')
       print('  ' + basename + '.model')
       print('  ' + basename + '.info.txt')
       print('')
     else:
       sys.stderr.write('Generating probability model...\n')
       gen = PCFG_Generator(a,b,p,w,1,15,B,R,T,O)
       sys.stderr.write('Sampling trees...\n')
       if args.depth != None:
         trees = gen.generate_trees(t, args.depth)
       else:
         trees = gen.generate_trees(t)

       sys.stderr.write('Writing output...\n')

       with open(basename + '.linetrees', 'wb') as f:
         for t in trees:
           f.write(str(t) + '\n')
       with open(basename + '.model', 'wb') as f:
         f.write(str(gen))
       with open(basename + '.info.txt', 'wb') as f:
         f.write('Random PCFG Info:\n')
         f.write('\n')
         f.write('PCFG model properties:\n')
         f.write('  Number of active (A) categories: %d\n' %a)
         f.write('  Number of awaited (B) categories: %d\n' %b)
         f.write('  Number of part-of-speech (P) categories: %d\n' %p)
         f.write('  Vocabulary size (W): %d\n' %w)
         if B != None:
           f.write('  Branching preference (left-branching probability): %s\n' %B)
         else:
           f.write('  No branching preference specified.\n')
         if R != None:
           f.write('  Recursion probability: %s\n' %R)
         else:
           f.write('  No recursion probability specified.\n')
         if T != None:
           f.write('  Branch termination (bottom-out) probability: %s\n' %T)
         else:
           f.write('  No branch termination (bottom-out) probability specified.\n')
         if O != None:
           f.write('  One-word sentence probability: %s\n' %O)
         else:
           f.write('  No one-word sentence probability specified.\n')
         f.write('\n')
         f.write('Sampled trees properties:\n')
         f.write('\n')
         if d != None:
           f.write('  Maximum allowed embedding depth for tree samples: %d\n' %d)
         else:
           f.write('  No limit on embedding depth.\n')
    
       sys.stderr.write('PCFG generation and tree sampling complete.\n\n')



main()


