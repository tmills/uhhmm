import sys, re, argparse

argparser = argparse.ArgumentParser('''
Converts the UHHMM model generated by a user-supplied iteration number to a CondModel format readable by Viterbi parsers.
''')
argparser.add_argument('-i', '--iter', dest='iter', action='store', default=1, help='Number of UHHMM iteration.')
argparser.add_argument('-d', '--dir', dest='dir', action='store', default='.', help='Path to directory to search for UHHMM output (defaults to ".").')
args, unknown = argparser.parse_known_args()

parse_row = re.compile(' *P *\( *([^ ]+) *\| *[^ ()]* *\( *([0-9]+) *, *(-?[0-9]*) *\), *([-0-9]+) *\) *= *([10]\.[0-9]+)')

I = int(args.iter)
dir = args.dir

# Set up paths to UHHMM model files
path_P = '%s/p_pos_%d.txt' %(dir, I)
path_F = '%s/p_fork_%d.txt' %(dir, I)
path_J_trans = '%s/p_j_trans_%d.txt' %(dir, I)
path_J_reduce = '%s/p_j_reduce_%d.txt' %(dir, I)
path_act_act = '%s/p_act_act_%d.txt' %(dir, I)
path_act_root = '%s/p_act_root_%d.txt' %(dir, I)
path_awa_cont = '%s/p_awa_cont_%d.txt' %(dir, I)
path_awa_exp = '%s/p_awa_exp_%d.txt' %(dir, I)
path_awa_next = '%s/p_awa_next_%d.txt' %(dir, I)
path_awa_start = '%s/p_awa_start_%d.txt' %(dir, I)
path_lex = '%s/p_lex_given_pos%d.txt' %(dir, I)

# Set up lists to track cluster labels, depths, and output lines
# so that the final cluster within each variable can be converted
# to '-'.
act = []
awa = []
pos = []
depth = 0
out = []

# Convert lines from each UHHMM model into rows of a conditional probability table
# UHHMM depth indices are off by 1, so add 1 to each depth value.
with open(path_P, 'rb') as f:
  for line in f:
    if line.strip() != '':
      v, c1, c2, d, prob = parse_row.match(line.strip()).groups()
      if not v in pos:
        pos.append(v)
      B = 'AWA' + c1
      out.append('P %s : %s = %s' %(B, v, prob))

with open(path_F, 'rb') as f:
  for line in f:
    if line.strip() != '':
      v, c1, c2, d, prob = parse_row.match(line.strip()).groups()
      d = int(d) + 1
      depth = max(d, depth)
      B = 'AWA' + c1
      P = 'POS' + c2
      v = v[1:]
      out.append('F %s %s %s : %s = %s' %(d, B, P, v, prob))

with open(path_J_trans, 'rb') as f:
  for line in f:
    if line.strip() != '':
      v, c1, c2, d, prob = parse_row.match(line.strip()).groups()
      d = int(d) + 2 
      depth = max(d, depth)
      B = 'AWA' + c1
      P = 'POS' + c2
      v = v[1:]
      out.append('J %s %s %s : %s = %s' %(d, B, P, v, prob))

with open(path_J_reduce, 'rb') as f:
  for line in f:
    if line.strip() != '':
      v, c1, c2, d, prob = parse_row.match(line.strip()).groups()
      d = int(d) + 1
      depth = max(d, depth)
      A = 'ACT' + c1
      B = 'AWA' + c2
      v = v[1:]
      out.append('J %s %s %s : %s = %s' %(d, B, A, v, prob))

with open(path_act_act, 'rb') as f:
  for line in f:
    if line.strip() != '':
      v, c1, c2, d, prob = parse_row.match(line.strip()).groups()
      d = int(d) + 1
      depth = max(d, depth)
      if not v in act:
        act.append(v)
      A = 'ACT' + c1
      B = 'AWA' + c2
      out.append('A %s 0 %s %s : %s = %s' %(d, B, A, v, prob))

with open(path_act_root, 'rb') as f:
  for line in f:
    if line.strip() != '':
      v, c1, c2, d, prob = parse_row.match(line.strip()).groups()
      d = int(d) + 1
      depth = max(d, depth)
      B = 'AWA' + c1
      P = 'POS' + c2
      out.append('A %s 0 %s %s : %s = %s' %(d, B, P, v, prob))

with open(path_awa_cont, 'rb') as f:
  for line in f:
    if line.strip() != '':
      v, c1, c2, d, prob = parse_row.match(line.strip()).groups()
      d = int(d) + 1
      depth = max(d, depth)
      if not v in awa:
        awa.append(v)
      B = 'AWA' + c1
      P = 'POS' + c2
      out.append('B %s 1 %s %s : %s = %s' %(d, B, P, v, prob))

with open(path_awa_exp, 'rb') as f:
  for line in f:
    if line.strip() != '':
      v, c1, c2, d, prob = parse_row.match(line.strip()).groups()
      d = int(d) + 1
      P = 'POS' + c1
      A = 'ACT' + c2
      out.append('B %s 0 %s %s : %s = %s' %(d, A, P, v, prob))

with open(path_awa_next, 'rb') as f:
  for line in f:
    if line.strip() != '':
      v, c1, c2, d, prob = parse_row.match(line.strip()).groups()
      d = int(d) + 1
      B = 'AWA' + c1
      A = 'ACT' + c2
      out.append('B %s 1 %s %s : %s = %s' %(d, B, A, v, prob))

with open(path_awa_start, 'rb') as f:
  for line in f:
    if line.strip() != '':
      v, c1, c2, d, prob = parse_row.match(line.strip()).groups()
      d = int(d) + 1
      depth = max(d, depth)
      A1 = 'ACT' + c1
      A2 = 'ACT' + c2
      out.append('B %s 0 %s %s : %s = %s' %(d, A1, A2, v, prob))

with open(path_lex, 'rb') as f:
  for line in f:
    if line.strip() != '':
      v, c1, c2, d, prob = parse_row.match(line.strip()).groups()
      d = int(d) + 1
      depth = max(d, depth)
      P = 'POS' + c1
      out.append('W %s : %s = %s' %(P, v, prob))

# Add in deterministic rules not contained in UHHMM models
out.append('A 0 1 T - : T = 1')
for p in pos:
  out.append('F 0 T %s : 1 = 1' %p)
  out.append('B 0 1 T %s : T = 1' %p)
  out.append('J 1 T %s : 0 = 1' %p)
for a in act:
  out.append('B 0 1 T %s : T = 1' %a)
  out.append('J 1 T %s : 0 = 1' %a)
for d in range(1, depth+1):
  for a in act:
    out.append('A %d 1 %s - : %s = 1' %(d, a, a))
for d in range(1, depth+1):
  for a in awa:
    out.append('A %d 1 %s - : %s = 1' %(d, a, a))

# Convert 0th and n+1st clusters to 'T' and '-' for use
# by the parser, remove '-' from lhs of conditional
# probability rules (so that it is never erroneously
# chosen).
act = sorted(act)
awa = sorted(awa)
end_signals = [act[-1], awa[-1]]

for l in out:
  wds = l.split()
  if wds[-3] in end_signals:
    continue 
  for i in range(len(wds)-2):
    if wds[i] in ['POS0', 'ACT0', 'AWA0']:
      wds[i] = 'T'
    elif wds[i] in end_signals:
      wds[i] = '-'
  print(' '.join(wds))
