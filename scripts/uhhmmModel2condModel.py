import sys, re, argparse

argparser = argparse.ArgumentParser('''
Converts the UHHMM model generated by a user-supplied iteration number to a CondModel format readable by Viterbi parsers.
''')
argparser.add_argument('-i', '--iter', dest='iter', action='store', default=1, help='Number of UHHMM iteration.')
argparser.add_argument('-d', '--dir', dest='dir', action='store', default='.', help='Path to directory to search for UHHMM output (defaults to ".").')
args, unknown = argparser.parse_known_args()

parse_row = re.compile(' *P *\( *([^ ]+) *\| *[^ ()]* *\( *([0-9]+) *, *(-?[0-9]*) *\), *([-0-9]+) *\) *= *([10]\.[0-9]+)')

I = int(args.iter)
dir = args.dir

path_P = '%s/p_pos_%d.txt' %(dir, I)
path_F = '%s/p_fork_%d.txt' %(dir, I)
path_J_trans = '%s/p_j_trans_%d.txt' %(dir, I)
path_J_reduce = '%s/p_j_reduce_%d.txt' %(dir, I)
path_act_act = '%s/p_act_act_%d.txt' %(dir, I)
path_act_root = '%s/p_act_root_%d.txt' %(dir, I)
path_awa_cont = '%s/p_awa_cont_%d.txt' %(dir, I)
path_awa_exp = '%s/p_awa_exp_%d.txt' %(dir, I)
path_awa_next = '%s/p_awa_next_%d.txt' %(dir, I)
path_awa_start = '%s/p_awa_start_%d.txt' %(dir, I)
path_lex = '%s/p_lex_given_pos%d.txt' %(dir, I)

act = []
awa = []
pos = []
depth = 0

def label(lab, num):
  if num == '0':
    return 'T'
  return lab + num

with open(path_P, 'rb') as f:
  for line in f:
    if line.strip() != '':
      v, c1, c2, d, prob = parse_row.match(line.strip()).groups()
      if not v in pos:
        pos.append(v)
      B = label('AWA', c1)
      print('P %s : %s = %s' %(B, v, prob))

with open(path_F, 'rb') as f:
  for line in f:
    if line.strip() != '':
      v, c1, c2, d, prob = parse_row.match(line.strip()).groups()
      d = int(d) + 1
      depth = max(d, depth)
      B = label('AWA', c1)
      P = label('POS', c2)
      v = v[1:]
      print('F %s %s %s : %s = %s' %(d, B, P, v, prob))

with open(path_J_trans, 'rb') as f:
  for line in f:
    if line.strip() != '':
      v, c1, c2, d, prob = parse_row.match(line.strip()).groups()
      d = int(d) + 1
      depth = max(d, depth)
      B = label('AWA', c1)
      P = label('POS', c2)
      v = v[1:]
      print('J %s %s %s : %s = %s' %(d, B, P, v, prob))

with open(path_J_reduce, 'rb') as f:
  for line in f:
    if line.strip() != '':
      v, c1, c2, d, prob = parse_row.match(line.strip()).groups()
      d = int(d) + 1
      depth = max(d, depth)
      A = label('ACT', c1)
      B = label('AWA', c2)
      v = v[1:]
      print('J %s %s %s : %s = %s' %(d, B, A, v, prob))

with open(path_act_act, 'rb') as f:
  for line in f:
    if line.strip() != '':
      v, c1, c2, d, prob = parse_row.match(line.strip()).groups()
      d = int(d) + 1
      depth = max(d, depth)
      if not v in act:
        act.append(v)
      A = label('ACT', c1)
      B = label('AWA', c2)
      print('A %s 0 %s %s : %s = %s' %(d, B, A, v, prob))

with open(path_act_root, 'rb') as f:
  for line in f:
    if line.strip() != '':
      v, c1, c2, d, prob = parse_row.match(line.strip()).groups()
      d = int(d) + 1
      depth = max(d, depth)
      B = label('AWA', c1)
      P = label('POS', c2)
      print('A %s 0 %s %s : %s = %s' %(d, B, P, v, prob))

with open(path_awa_cont, 'rb') as f:
  for line in f:
    if line.strip() != '':
      v, c1, c2, d, prob = parse_row.match(line.strip()).groups()
      d = int(d) + 1
      depth = max(d, depth)
      if not v in awa:
        awa.append(v)
      B = label('AWA', c1)
      P = label('POS', c2)
      print('B %s 1 %s %s : %s = %s' %(d, B, P, v, prob))

with open(path_awa_exp, 'rb') as f:
  for line in f:
    if line.strip() != '':
      v, c1, c2, d, prob = parse_row.match(line.strip()).groups()
      d = int(d) + 1
      P = label('POS', c1)
      A = label('ACT', c2)
      print('B %s 0 %s %s : %s = %s' %(d, A, P, v, prob))

with open(path_awa_next, 'rb') as f:
  for line in f:
    if line.strip() != '':
      v, c1, c2, d, prob = parse_row.match(line.strip()).groups()
      d = int(d) + 1
      B = label('AWA', c1)
      A = label('ACT', c2)
      print('B %s 1 %s %s : %s = %s' %(d, B, A, v, prob))

with open(path_awa_start, 'rb') as f:
  for line in f:
    if line.strip() != '':
      v, c1, c2, d, prob = parse_row.match(line.strip()).groups()
      d = int(d) + 1
      depth = max(d, depth)
      A1 = label('ACT', c1)
      A2 = label('ACT', c2)
      print('B %s 0 %s %s : %s = %s' %(d, A1, A2, v, prob))

with open(path_lex, 'rb') as f:
  for line in f:
    if line.strip() != '':
      v, c1, c2, d, prob = parse_row.match(line.strip()).groups()
      d = int(d) + 1
      depth = max(d, depth)
      P = label('POS', c1)
      print('W %s : %s = %s' %(P, v, prob))

#print('A 0 1 T - : T = 1')
#for p in pos:
#  print('P %s : %s = 1' %(p, p))
